\subsection{Accurate Dynamic Dependency Depth Analysis}
\label{subsec:furthers-dep-depth}
%
The program's adaptivity in our formal model,
% which we define over the program's execution-based dependency graph from the dynamic 
% analysis 
in Definition~\ref{def:trace_adapt} also
 comes across an over-approximation on the program's
 intuitive adaptivity rounds.
It is resulted from difference between its Dependency Depth analysis and the \emph{variable may-dependency} definition.
It occurs when the weight is computed over the traces different from the traces used in 
witness the \emph{variable may-dependency} relation.

As shown in following motivating example, 
\include{examples/multipleRoundsSingle}
% \subsubsection{Examples}
% \label{subsubsec:furthers-dep-depth-examples}
% % \subimport{examples/}{multipleRoundsSingle.tex}
% \include{examples/multipleRoundsSingle}
%%
\subsubsection{Proposed Methodology}
\label{subsubsec:furthers-dep-depth}
% \input{~/dynamic/relatedwork.tex}
1. define the variables dependency relation over two witness traces and an initial trace.
\\
2. Quantify the weight of every edge in the execution-based dependency graph, w.r.t. to the witness traces.
\\

\subsection{Path Sensitive Reachability Bound Analysis}
\label{subsec:furthers-reachability}
In existing static reachability bound analysis, 
it comes across an over-approximation on the estimation due to its path-insensitive nature. 
It occurs when the control flow can be decided in a particular way in front of conditional branches, 
while the static analysis fails to witness. 
As shown in following example, 
\include{examples/multipleRoundsOdd}

% as follo
\subsubsection{Proposed Methodology}
\label{subsubsec:furthers-reachability}
Based on Existing Methodology on reachability bound analysis, design new algorithm computing the 
reachability bounds for every labeled command.
Comparing to just compute the reachability bound for the while loop command, new methodology improves the accuracy of the 
reachability bound for every labeled command.

\subsection{Static Adaptivity Computation towards Completeness}
\label{subsec:furthers-adaptcomplete}
The Algorithm is conditional completeness as proved in appendix, but Algorithm~\ref{alg:adaptscc} isn't.
In the algorithm design at line: in Algorithm~\ref{alg:adaptscc}, an over-approximation happens here. 

As  following motivating example shows.
\subsubsection{Proposed Methodology}
\label{subsubsec:furthers-adaptcomplete-methodology}
%
1. looking into more over-approximated example and summarize the common properties of these examples.
\\
2. Modify the Algorithm~\ref{alg:adaptscc}, targeting the line: 12 of the algorithm. 
The goal is to reduce the over-approximation in computing adaptivity statically.
\subsection{Generalization on Program Resource Cost}
\label{subsec:furthers-cost}

\subsubsection{Introduction and Related Work}
\label{subsubsec:furthers-cost-backgroung}
There are two categories of the program cost analysis, Type-System Based and Static Program Analysis Based. But both of the
works in these two areas fails to recognize the case where program resource consumption is decreased implicitly.
\paragraph*{Type-System Based}
\paragraph*{Static Program Analysis Based}

\subsubsection{Motivating Example}
\label{subsubsec:furthers-cost-example}

\subsubsection{Proposed Methodology}
\label{subsubsec:furthers-cost-methodology}
Following the same system structure as $\THESYSTEM$,
by modifying the restriction on finite walk, compute different resource cost for program.

