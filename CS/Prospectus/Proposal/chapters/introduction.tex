% %%%% Benefit of reasoning about 
% \subsection{Motivation of Reasoning about Adaptivity}
% % 
% In Section~\ref{sec:intro-background},
% I introduce the background and limitation of the 
% adaptive data analysis, 
% and the motivation of reasoning about the \emph{adaptivity} quantity property 
% for adaptive data analysis.
% % in Section~\ref{sec:intro-motivation}.
% % analyzing 
% In order to analyze this quantity property for the adaptive data analysis, there are 3 challenges
% % problems encountered.
% introduced.
% % I introduce these three problems
% % and the full-spectrum analysis methodologies developed according to these problems 
% Targeting to the three challenges, I introduce the methodologies 
% of the program analysis framework for the adaptive data analysis's adaptivity property
% accordingly, in Section~\ref{sec:intro-adapt}.
% Concretely, 
% % the full-spectrum 
% this analysis framework is developed through the language formalization,
% the execution-based analysis, and the static-based program analysis.
% %
% Based on the implementation and experimental results on this analysis framework, 
% I propose three significant 
% further features can be improved 
% % in the analysis methodologies 
% in Section~\ref{sec:intro-improve}, 
% and plan to finish these improvements 
% before the final defense.
% %
% % Next, based on the implementation and experimental results, I proposed two significant 
% % further features can be improved for my analysis framework, and plan to finish the improvement 
% % before the final defense.
% %
% Then, in Section~\ref{sec:intro-cost}, through two observations, 
% I introduce the motivations and methodologies
% for 
% % the accurate 
% analyzing program's \emph{non-monotonic} quantitative property accurately.
% with implicit cost decreases.
% \\
% 1. traditional program's resource cost analysis failed to consider the case where the program's cost could decrease 
% implicitly, 
% \\
% 2. and 
% % when there isn't a dependency relation between variables.
% the resource consumption during the program 
% execution increases and particularly decreases implicitly in the same way as the program's adaptivity, 
% % Specifically, in line 5 
% % where the list is re-written and the heap consumption is decreased implicitly. 
% % This implicit decrease 
% % of the cost works the same as the program's adaptivity decreases.
% I am interested in improving the accuracy of the program's general resource cost analysis
% by 
% % onto the program's resource cost analysis. 
% % Use this framework,
% Through the generalized \emph{adaptivity} analysis framework.
% I will give
% a more accurate resource cost estimation by taking the program's implicit resource cost into consideration, comparing 
% to the worst case cost analysis in a traditional way.
% \paragraph{Background and Motivation\todo{Rewrite into Program Analysis of the Quantitative Property}}
% \label{sec:intro-background}
Program analysis analyzes the behaviors of a computer program.
One of the most significant behaviors with respect to programs is the execution correctness behavior, which determines whether a program executes correctly without getting stuck because of bugs.
 The execution correctness can be proved by showing the functional correctness property of the program with the help of some formal verification methods such as type system and program logic.
 Much attention in the programming language community has focused on the functional correctness property, while not enough effort was put on, a variety of those non-function properties, considering its wide potential applications in modern society. 
 A few decades ago, computer programs were only used for research or business purpose and the expectation of computer programs was just to execute correctly without bugs. 
 
 \highlight{
However, the expectation has also changed along with the popularity of mobile devices and wide applications of big data. 
To provide people with high-quality
 service through mobile devices,
 it is not enough for these programs running on mobile phones or those programs handling big data, 
 to just run without bugs. 
 These programs are also expected to run efficiently, produce accurate outputs, do not leak the data, etc.,
 when running on mobile device and handling the big data.
%  \\
 In this sense, the non-functional properties
 come into play in the new era.
 }
%  We think programs on mobile devices are of great significance in today's life.
% %  To provide people with high-quality
% %  service through mobile devices,
% we choose to study the non-functional properties of programs,
% specifically the reachability quantitative property in this proposal.
% Skeleton:
% Importance of the Program Execution Property in different areas.


% In Machine Learning Area, the Adaptivity Quantity is significant
% ==> Major Work I
% \\
\highlight{
For a large amount of mobile devices applications
such as video or music player, game, shopping, etc.,
a high-quality
service 
aims to provide the users with accurate personalized services.
% machine learning algorithm analysis results over data,
Accurate personalized services relies heavily on the data analysis results.
% These analysis results are used to provide the users with accurately personalized services.
This brings my attention on the
% The 
first non-functional behavior of the data analysis programs, 
i.e., the accuracy quality of the data analysis results.
% in their machine learning algorithms.
% comes from the machine learning area which is popular and widespread applied in our daily mobile life.
% In this area,
% The first execution property 
% the data collected from a large number of mobile users also deserves our attention.
We look at data analysis which analyzes sample data to get some generalized results
% with respect to the population
on the population data
where the sample is drawn.
Then, these generalized results are used to provide
users who come from the unknown population with personalized services.
Some users occasionally receive inaccurate services,
because they are not in the sample data but still provided with the services by using the generalized analysis results.
In these situations, the generalization error comes into play. 
It measures the difference of the analysis results between the sample data and population data, 
% The generalization error measures the difference of property from the sample data and population, 
showing the reliability of the data analysis and reflecting the quality of the service based on it.
% of showing the true properties of the population. 
High generalization error makes the analysis results
%  of these programs 
not reliable.
This generalization error of a data analysis program over sample data with respect to the population
is one of the important program's reachability quantitative properties.
% It could be useful to have the program 
% This generalization error 
Fortunately, studies found that some quantitative properties of data analysis programs can help to control the generalization error, especially when the data analysis is adaptive.
These properties are the first reachability quantitative properties we are interested in
analyzing.
% \\
}
% We use the static analysis technique to best exploit the benefit of these non-functional quantitative properties in resource usage and data analysis. However, to fully utilize the aforementioned benefits of the static analysis on these quantitative properties, the appropriate implementation is inevitable. To this end, we also take one step in algorithmizing a refinement type and effect system, which is used to statically estimate the properties of resource usage. In precise, the resource is the evaluation cost of programs in this proposal.

% ==> Major Work II
% In Resource Cost Analysis Area, the Reachability-Bound is significant.
% \\
\highlight{
A high-quality
service in people's mobile device life does not
just mean the accuracy of service but also
the performance, the privacy, etc., of the service. 
% non-functional properties on resource usage, one of the most useful properties concerning mobile devices. 
% Suppose we are playing an online game on our smartphones, what do we care about? 
% We care about the performance of the game, in another word, if it runs fast.
% We care about whether the game crashed due to being out of memory, and so on.
Suppose we are playing an online game on our smartphones, what do we care about? 
In games such as racing, 
we care about the performance of the game, in another word, if it runs fast, if it crashes due to being out of memory, and so on.
% We care about whether the game crashed due to being out of memory, and so on.
In some other strategy games, we also care about whether my strategy is leaked to other party, i.e., the privacy quality of the game.
% \\
% Additionally, resource usage is the key for embedded systems or wearable devices.
% In this sense, the study of the non-functional properties of resource usage is of great practical value.
% We observe that the non-functional properties of resource usage or data leakage are usually
% related to two aspects, reachability and quantity.
% \\
We observe that performance of the program is usually related to resource cost, which is
% to how fast the program runs, which largely 
mainly determined by
whether some pieces of code are executed and how times these codes are executed.
From the same perspective, we observe that whether the data is leaked is also related to whether certain pieces of the program code are executed,
and how many times these codes are executed.
% \\
This brings my attention to another two non-functional properties, the reachability and execution times of the certain program codes.
The two properties combined is a reachability quantitative property because it has both the reachable and quantitative aspects.
% \todo{the program's resource cost and the data leakage}.
% \\
% Providing information 
Specifying certain bounds
on this reachability quantitative property
can help to control the usage of some resources and the data.
%  and improve the program reliability,
% or specify certain bounds on the target resource to 
In this sense, it can help to guarantee both the performance and safety properties for the high-quality services on mobile device.
% For instance, an update on a mobile app does not significantly slow down the performance
% of this update and will not use resources exceeding certain bounds specified before.
}

% We use combinations of 
% We combine the
% execution-based and static-based
\highlight{We design new program
analysis frameworks
%  into the new
% analysis frameworks 
to best exploit the benefit of these reachability quantitative properties in data analysis and resource usage.
However, to fully utilize the aforementioned benefits of the new analysis frameworks on these reachability quantitative properties, 
the appropriate implementation is inevitable. 
To this end, we also take one step in algorithmizing and implementing the program analysis frameworks,
% through
% program analysis framework, 
which is used to automatically estimate these properties.
}

Last but not least, these reachability quantitative properties are not limited to static analysis.
We are not only interested in programs implementing the specific algorithm, but also willing to study these lower bound and upper bound of the algorithm itself.
% To this end, we use the formal verification method to study standard algorithms such as sorting and searching in a comparison-based computation model.

% \todo{
% In program quantitative property analysis area, the methodologies are mainly based on
% two different kinds of analysis techniques, type-system-based and the data-flow/control-flow analysis based.
% % There are mainly two categories of methodology in the static program resource cost analysis areas, 
% % through type-system based and data-flow/control-flow analysis based. 
% % They can be summarized as follows, but to the best of my knowledge,
% % all these works in the two categories fail to recognize the case where program resource consumption is decreased implicitly.
% \paragraph*{Type-System Based}
% Existing
% static program analysis based type-system is mainly through 
% effect systems, 
% % control-flow analysis, and data-flow analysis~\cite{ryder1988incremental}. 
% % The idea of statically estimating a sound upper bound for the adaptivity from the semantics is indirectly inspired by prior 
% Previous work on cost analysis via effect systems~\cite{cciccek2017relational,radivcek2017monadic,qu2019relational} statically estimating a sound upper bound for program's cost accumulatingly.
% % The idea of defining adaptivity using data flow is inspired by the work of graded 
% Hoare logic~\cite{gaboardi2021graded}, and amortized type system~\cite{hoffmann_jost_2022}.
% %
% In these systems, the cost is accumulating through the type of induction. 
% The only way to save the cost into the potential
% type, as in~\cite{GustafssonEL05} and \cite{hoffmann_jost_2022}, 
% is through explicit abstraction or data structure de-allocation.
% That is to say, they cannot deal with the case where the cost (for example the adaptivity) decreases when there isn't a dependency relation between variables.
% \paragraph*{Data-flow/Control-flow Analysis Based}
% Existing static program analysis works via the control flow or data flow analysis 
% in program resource cost analysis 
% mainly falls into two areas, the program complexity analysis, and worst case execution time analysis. 
% They are focusing on analyzing the cost of the entire program. 
% The techniques are based on
% type system~\cite{CicekBG0H17, RajaniG0021}, Hoare logic~\cite{CarbonneauxHS15}, abstract interpretation~\cite{GustafssonEL05, HumenbergerJK18},
% invariant generation through cost equations or ranking functions~\cite{BrockschmidtEFFG16,AlbertAGP08,AliasDFG10,Flores-MontoyaH14}
% or a combination of program abstraction and invariant inferring~\cite{GulwaniZ10, SinnZV17, GulwaniJK09}.
% In general, these techniques give the approximated upper bound of the program's total running time or resource cost.
% However, they failed to consider the case where the program's cost could decrease when there isn't a dependency relation between variables.
% \\
% While some work in paper [][][]in the context of memory usage for specific models of garbage collection [5,8,12],
% they don't give a generic framework to estimate the non-cumulative quantitative property.
% \\
% The work in paper "Non-cumulative Resource Analysis" gave a generic resource analysis framework for a today’s imperative language enriched with instructions to acquire and release resources. 
% However, they failed in the path-sensitive case. Their method is also imprecise in the sense that they over-approximate the
% set of acquire instructions globally for the local execution location.
% }


% \subsection{Proposal Outline}
% \label{sec:intro-outline}
% This proposal 
% \paragraph{Automated Program Analysis Framework for Adaptive Data Analysis (In Improvements)}
% \label{sec:intro-adapt}

% \paragraph{Path-Sensitive Reachability-Bound Analysis (In Preparation)}
% \label{sec:intro-reachability}

% \paragraph{Towards Accurate Program Non-Monotonic Quantitative Property Analysis (In Preparation)}
% \label{sec:intro-cost}
% Moving towards the area of program's quantitative property analysis,
% % Then, motivated by the two following aspects, 
% there are two interesting observations as follows.
% % I am interested 
% These two observations motivated me in 
% % improving the accuracy of the program's general resource cost analysis
% improving the accuracy of the program's general resource cost analysis
% by generalizing this \emph{adaptivity} analysis framework.
% \begin{itemize}
% \item 
% % In the traditional program's resource cost and quantitative property analysis,
% There are two research areas in the traditional program's resource cost and quantitative property analysis.
% % of program cost analysis, 
% One area is type-system based and the other is data-flow/control-flow analysis based. 
% In the type-system design-based areas (\cite{GustafssonEL05}, \cite{hoffmann_jost_2022}), 
% the analysis technique requires explicit abstraction or data structure de-allocation in order to save or reduce the cost.
% The
% works in both of these two areas fail to recognize the case where program resource consumption or quantitative properties 
% are decreased implicitly or increased \emph{non-monotonically}.
% \item This kind of resource consumption or quantitative properties during the program 
% execution increase and particularly decrease implicitly in the same way as the program's adaptivity. 
% This is explained in detail through an example in Section~\ref*{sec:generalization}.
% \end{itemize}
% Based on the observations above, 
% I plan to develop
% an accurate program \emph{non-monotonic} quantitative property analysis framework through generalizing 
% my \emph{adaptivity} analysis framework.
% This framework can give more accurate cost bound than traditional worst-case resource cost estimation methods,
% by taking the program's implicit resource cost decreasing into consideration.
% compared 
% to the worst-case cost analysis in the traditional way.

\paragraph*{Proposal Structure}
To sum up, this proposal covers the following topic in each part.
\begin{enumerate}
 \item \redd{PART I}: A program analysis framework for analyzing the adaptivity for the program that implements an adaptive data analysis.
 \item \redd{PART II} A path-sensitive reachability-bound analysis algorithm for computing the program's accurate reachability-bound.
% \item A while-like language extended with query request feature, named {\tt Query While} Language, 
% used to implement 
% the adaptive data analysis in Section~\ref{sec:language}.
% \item A formal adaptivity model through execution-based adaptivity analysis in Section~\ref{sec:dynamic}.
% \item A static program analysis algorithm named {\THESYSTEM} in Section~\ref{sec:static}.
% \item Three proposed further features to be improved for the adaptivity analysis framework,
% % based on the 
% % % formal adaptivity model and {\THESYSTEM}, 
% % full-spectrum 
% in Section~\ref{sec:furthers}.
% % presented in Section~\ref{sec:language},~\ref{sec:dynamic} and~\ref{sec:static},
% This proposed work is planned to be done before the final defense.
% \item A proposed automated program non-monotonic quantitative quantity analysis framework in \redd{PART III}.
% generalized from {\THESYSTEM} in Section~\ref{sec:generalization}. 
% The analysis framework design is expected to be done with the implementation start off before the final defense.
% \item A proposed plan for solving the CFL-reachability problem via reduction into the {\THESYSTEM} framework in Section~\ref{sec:cfl_reduction},
% expected to start before final defense and developing further after.
\end{enumerate}