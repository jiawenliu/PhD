% %%%% Benefit of reasoning about 
% \subsection{Motivation of Reasoning about Adaptivity}
% % 
% In Section~\ref{sec:intro-background},
% I introduce the background and limitation of the 
% adaptive data analysis, 
% and the motivation of reasoning about the \emph{adaptivity} quantity property 
% for adaptive data analysis.
% %  in Section~\ref{sec:intro-motivation}.
% % analyzing 
% In order to analyze this quantity property for the adaptive data analysis, there are 3 challenges
% % problems encountered.
% introduced.
% % I introduce these three problems
% % and the full-spectrum analysis methodologies developed according to these problems 
% Targeting to the three challenges, I introduce the methodologies 
% of the program analysis framework for the adaptive data analysis's adaptivity property
% accordingly, in Section~\ref{sec:intro-adapt}.
% Concretely, 
% % the full-spectrum 
% this analysis framework is developed through the language formalization,
% the execution-based analysis, and the static-based program analysis.
% %
% Based on the implementation and experimental results on this analysis framework, 
% I propose three significant 
% further features can be improved 
% % in the analysis methodologies 
% in Section~\ref{sec:intro-improve}, 
% and plan to finish these improvements 
% before the final defense.
% %
%  % Next, based on the implementation and experimental results, I proposed two significant 
%  % further features can be improved for my analysis framework, and plan to finish the improvement 
%  % before the final defense.
%  %
%  Then, in Section~\ref{sec:intro-cost}, through two observations, 
%  I introduce the motivations and methodologies
%  for 
% %  the accurate 
% analyzing program's \emph{non-monotonic} quantitative property accurately.
%   with implicit cost decreases.
% \\
% 1. traditional program's resource cost analysis failed to consider the case where the program's cost could decrease 
% implicitly, 
% \\
% 2. and 
% % when there isn't a dependency relation between variables.
% the resource consumption during the program 
% execution increases and particularly decreases implicitly in the same way as the program's adaptivity, 
% % Specifically, in line 5 
% % where the list is re-written and the heap consumption is decreased implicitly. 
% % This implicit decrease 
% % of the cost works the same as the program's adaptivity decreases.
% I am interested in improving the accuracy of the program's general resource cost analysis
% by 
% % onto the program's resource cost analysis. 
% % Use this framework,
% Through the generalized \emph{adaptivity} analysis framework.
% I will give
% a more accurate resource cost estimation by taking the program's implicit resource cost into consideration, comparing 
% to the worst case cost analysis in a traditional way.
% \paragraph{Background and Motivation\todo{Rewrite into Program Analysis of the Quantitative Property}}
%  \label{sec:intro-background}
Program analysis analyzes behaviours of a computer program.
One of the most significant behaviours with respect to programs is the execution correctness behaviour, which determines whether a program executes correctly without getting stuck because of bugs.
 The execution correctness can be proved by showing the functional correctness property of the program with the help of some formal verification methods such as type system and program logic.
 Many attentions in programming language community have focused on the functional correctness property, while not enough efforts were put on, a variety of those non-function properties, considering its wide potential applications in modern society. 
 A few decades ago, computer programs were only used for research or business purpose and the expectation of computer program was just executing correctly without bugs. 
 However, the expectation has also changed along with the popularity of mobile devices and wide applications of big data. 
 It is not enough for these programs running on mobile phones or those programs handling big data, 
 to just run without bugs. 
 The non-functional execution properties come into play in the new era.

 We think programs on mobile devices of great significance in today's life.
 In order to provide people with high quality
 service through mobile devices,
we choose to study the non-functional properties on programs.
 Skeleton:
Importance of the Program Execution Property in different areas.


% In Machine Learning Area, the Adaptivity Quantity is significant
% ==> Major Work I
% \\
Existing high quality
service through mobile devices relies heavily on the data analysis results
%  machine learning algorithm analysis results over data,
for providing users with personalized accurate services. This brings my attention on the
% The 
first non-functional execution behaviour in these data analysis programs, i.e., the quality of the data analysis results.
%  in their machine leanring algorithms.
%   comes from the machine learning area which is popular and widespreadly applied in our daily mobile life.
% In this area,
% The first execution property 
% the data collected from large amount of mobile users also deserves our attention.
We look at data analysis which analyzes sample data to get some generalized properties of the big data where the sample is drawn from.
The generalization property of data analysis program over sample data with respect to the population is one of the important non-functional properties of programs.
The generalization error measures the difference of property from the sample data and population, showing the reliability of the data analysis of showing the true properties of the population. 
High generalization error makes the analysis result of these programs not reliable.
% It could be useful to have program 
% This generalization error 
Fortunately, studies found that some quantitative properties of data analysis programs can help to control the generalization error, especially when the data analysis is adaptive.
These properties are the first non-functional execution properties we are interested in
analyzing.
% \\
% We use static analysis technique to best exploit the benefit of these non-functional quantitative properties in resource usage and data analysis. However, to fully utilize the aforementioned benefits of the static analysis on these quantitative properties, the appropriate implementation is inevitable. To this end, we also take one step in algorithmizing a refinement type and effect system, which is used to statically estimate the properties on resource usage. In precise, the resource is the evaluation cost of programs in this proposal.

% ==> Major Work II
% In Resource Cost Analysis Area, the Reachability-Bound is significant.
% \\
High quality
service in people's mobile device life do not just relies on the accuracy of service but also the
 efficiency of the service. 
This brings my attention on another non-functional execution property, the program's resource cost.
% non-functional properties on resource usage, one of the most useful properties with respect to mobile devices. 
Suppose we are playing an online game on our smartphones, what do we care about? We care about the performance of the game, in another word, if it runs fast. We care about whether the game crashed due to out of memory, and so on. Additionally, resource usage is the key for embedded systems or wearable devices. In this sense, the study on the non-functional properties on resource usage is of great practical value. We observe that the non-functional properties on resource usage are usually quantitative, specifying certain bounds on the target resource to guarantee the performance. For instance, an update on a mobile app does not significantly slow down the performance if this update will not use resources exceeding certain bounds specified before.


% We use combinations of 
We combine the
execution-based and static-based
analysis techniques into the new
analysis frameworks to best exploit the benefit of these non-functional properties in data analysis and resource usage. However, to fully utilize the aforementioned benefits of the new analysis frameworks on these non-functional properties, the appropriate implementation is inevitable. 
To this end, we also take one step in algorithmizing the analysis frameworks
%  through
% program analysis framework, 
which is used to formalize and statically estimate these properties.

Last but not least, these non-functional properties are not limited to static analysis. We are not only interested in programs implementing specific algorithm, but also willing to study these lower bound and upper bound of the algorithm itself.
% To this end, we use formal verification method to study standard algorithms such as sorting, searching in a comparison-based computation model.

% \todo{
%     In program quantitative property analysis area, the methodologies are mainly based on
%     two different kinds of analysis techniques, type-system-based and the  data-flow/control-flow analysis based.
% %     There are mainly two categories of methodology in the static program resource cost analysis areas, 
% % through type-system based and data-flow/control-flow analysis based. 
% % They can be summarized as follows, but to the best of my knowledge,
% % all these works in the two categories fail to recognize the case where program resource consumption is decreased implicitly.
% \paragraph*{Type-System Based}
% Existing
% static program analysis based type-system is mainly through 
% effect systems, 
% % control-flow analysis, and data-flow analysis~\cite{ryder1988incremental}. 
% % The idea of statically estimating a sound upper bound for the adaptivity from the semantics is indirectly inspired by prior 
% Previous work on cost analysis via effect systems~\cite{cciccek2017relational,radivcek2017monadic,qu2019relational} statically estimating a sound upper bound for program's cost accumulatingly.
% % The idea of defining adaptivity using data flow is inspired by the work of graded 
% Hoare logic~\cite{gaboardi2021graded}, and amortized type system~\cite{hoffmann_jost_2022}.
% %
% In these systems, the cost is accumulating through the type of induction. 
% The only way to save the cost into the potential
% type, as in~\cite{GustafssonEL05} and \cite{hoffmann_jost_2022}, 
% is through explicit abstraction or data structure de-allocation.
% That is to say, they cannot deal with the case where the cost (for example the adaptivity) decreases when there isn't a dependency relation between variables.
% \paragraph*{Data-flow/Control-flow Analysis Based}
% Existing static program analysis works via the control flow or data flow analysis 
% in program resource cost analysis 
% mainly falls into two areas, the program complexity analysis, and worst case execution time analysis. 
% They are focusing on analyzing the cost of the entire program. 
% The techniques are based on
% type system~\cite{CicekBG0H17, RajaniG0021}, Hoare logic~\cite{CarbonneauxHS15}, abstract interpretation~\cite{GustafssonEL05, HumenbergerJK18},
% invariant generation through cost equations or ranking functions~\cite{BrockschmidtEFFG16,AlbertAGP08,AliasDFG10,Flores-MontoyaH14}
% or a combination of program abstraction and invariant inferring~\cite{GulwaniZ10, SinnZV17, GulwaniJK09}.
% In general, these techniques give the approximated upper bound of the program's total running time or resource cost.
% However, they failed to consider the case where the program's cost could decrease when there isn't a dependency relation between variables.
% \\
% While some work in paper [][][]in the context of memory usage for specific models of garbage collection [5,8,12],
% they don't give a generic framework to estimate the non-cumulative quantitative property.
% \\
% The work in paper "Non-cumulative Resource Analysis" gave a generic resource analysis framework for a today’s imperative language enriched with instructions to acquire and release resources. 
% However, they failed in the path-sensitive case. Their method is also imprecise in the sense that they over-approximate the
% set of acquire instructions globally for the local execution location.
% }


% \subsection{Proposal Outline}
% \label{sec:intro-outline}
% This proposal 
% \paragraph{Automated Program Analysis Framework for Adaptive Data Analysis (In Improvements)}
% \label{sec:intro-adapt}

% \paragraph{Path-Sensitive Reachability-Bound Analysis (In Preparation)}
% \label{sec:intro-reachability}

% \paragraph{Towards Accurate Program Non-Monotonic Quantitative Property Analysis (In Preparation)}
% \label{sec:intro-cost}
% Moving towards the area of program's quantitative property analysis,
% % Then, motivated by the two following aspects, 
% there are two interesting observations as follows.
% % I am interested 
% These two observations motivated me in 
% % improving the accuracy of the program's general resource cost analysis
% improving the accuracy of the program's general resource cost analysis
% by generalizing this \emph{adaptivity} analysis framework.
% \begin{itemize}
%  \item 
% %  In the traditional program's resource cost and quantitative property analysis,
%  There are two research areas in the traditional program's resource cost and quantitative property analysis.
% %  of program cost analysis, 
% One area is type-system based and the other is data-flow/control-flow analysis based. 
% In the type-system design-based areas (\cite{GustafssonEL05}, \cite{hoffmann_jost_2022}), 
% the analysis technique requires explicit abstraction or data structure de-allocation in order to save or reduce the cost.
%  The
%  works in both of these two areas fail to recognize the case where program resource consumption or quantitative properties 
%  are decreased implicitly or increased \emph{non-monotonically}.
%  \item This kind of resource consumption or quantitative properties during the program 
%  execution increase and particularly decrease implicitly in the same way as the program's adaptivity. 
%  This is explained in detail through an example in Section~\ref*{sec:generalization}.
% \end{itemize}
%  Based on the observations above, 
%  I plan to develop
%  an accurate program \emph{non-monotonic} quantitative property analysis framework through generalizing 
%  my \emph{adaptivity} analysis framework.
%  This framework can give more accurate cost bound than traditional worst-case resource cost estimation methods,
%  by taking the program's implicit resource cost decreasing into consideration.
%  compared 
%  to the worst-case cost analysis in the traditional way.

\paragraph*{Proposal Structure}
To sum up, this proposal covers the following topic in each following part.
\begin{enumerate}
    \item A program Analysis framework for analyzing the adaptivity for adaptive data analysis in \redd{PART I}.
    \item A Path-sensitive Reachability-Bound analysis algorithm for computing the accurate reachability-bound in \redd{PART II}
% \item A while-like language extended with query request feature, named {\tt Query While} Language, 
% used to implement 
% the adaptive data analysis in Section~\ref{sec:language}.
% \item A formal adaptivity model through execution-based adaptivity analysis in Section~\ref{sec:dynamic}.
% \item A static program analysis algorithm named {\THESYSTEM} in Section~\ref{sec:static}.
% \item Three proposed further features to be improved for the adaptivity analysis framework,
% % based on the 
% % % formal adaptivity model and {\THESYSTEM}, 
% %  full-spectrum 
% in Section~\ref{sec:furthers}.
% %  presented in Section~\ref{sec:language},~\ref{sec:dynamic} and~\ref{sec:static},
%  This proposed work is planned to be done before the final defense.
\item A proposed automated program non-monotonic quantitative quantity analysis framework in \redd{PART III}.
% generalized from {\THESYSTEM} in Section~\ref{sec:generalization}. 
% The analysis framework design is expected to be done with the implementation start off before the final defense.
% \item A proposed plan for solving the CFL-reachability problem via reduction into the {\THESYSTEM} framework in Section~\ref{sec:cfl_reduction},
% expected to start before final defense and developing further after.
\end{enumerate}