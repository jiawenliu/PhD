In this chapter, we formally introduce the language we will focus on for writing data analyses.  
This is a simple loop language with some primitives for calling queries. 
After defining the syntax of the language and showing an example, we will define its trace-based operational semantics. 
This is the main technical ingredient we will use to define the program's adaptivity.

%
%
\paragraph{Syntax Extension}
\[
\begin{array}{llll}
\mbox{Arithmetic Operators} 
& \oplus_a & ::= & + ~|~ - ~|~ \times 
%
~|~ \div ~|~ \max ~|~ \min\\  
% ~|~ \div \\  
\mbox{Boolean Operators} 
& \oplus_b & ::= & \lor ~|~ \land
\\
%
\mbox{Relational Operators} 
& \sim & ::= & < ~|~ \leq ~|~ == 
\\  
%
\mbox{Arithmetic Expression} 
& \aexpr & ::= & 
n ~|~ {x} ~|~ \aexpr \oplus_a \aexpr  
 ~|~ \elog \aexpr  ~|~ \esign \aexpr
\\
%
\mbox{Boolean Expression} & \bexpr & ::= & 
%
\etrue ~|~ \efalse  ~|~ \neg \bexpr
 ~|~ \bexpr \oplus_b \bexpr
%
~|~ \aexpr \sim \aexpr 
\\
%
\mbox{Expression} & \expr & ::= & v ~|~ \aexpr ~|~ \bexpr ~|~ [\expr, \dots, \expr]
\\  
%
\mbox{Value} 
& v & ::= & { n ~|~ \etrue ~|~ \efalse ~|~ [] ~|~ [v, \dots, v]}  
\\ 
&&&
\highlight
{
~|~ (r, x_1, \ldots, x_n) := c
}
\\
%
\mbox{Query Expression} 
& {\qexpr} & ::= 
& { \qval ~|~ \aexpr ~|~ \qexpr \oplus_a \qexpr ~|~ \chi[\aexpr]} 
\\
%
\mbox{Query Value} & \qval & ::= 
& {n ~|~ \chi[n] ~|~ \qval \oplus_a  \qval ~|~ n \oplus_a  \chi[n]
    ~|~ \chi[n] \oplus_a  n}
\\
% \\%
\mbox{Label} 
& l & ::= & (n \in \mathbb{N} \cup \{\lin, \lex\}) ~|~ (l, n)
\\ 
%
\mbox{Labeled Command} 
& {c} & ::= &  
\clabel{\assign{x}{\expr}}^l 
~|~ \clabel{\assign{x}{\query(\qexpr)}}^l
~|~  \clabel{\eskip}^l
~|~ \ewhile \clabel{\bexpr}^{l} \edo {c}
~|~ \eif(\clabel{\bexpr}^{l} , {c}, {c}) 
\\ 
&&&
\highlight
{
~|~ \clabel{\efun}^l: x(r, x_1, \ldots, x_n) := c
~|~ \clabel{\assign{x}{\ecall(x, e_1, \ldots, e_n)}}^l
}
~|~ {c};{c}  
\\ 
% \\
\mbox{Event} 
& \event & ::= & 
    ({x}, l, v, \bullet) ~|~ ({x}, l, v, \qval)  ~~~~~~~~~~~ \mbox{Assignment Event} \\
&&& ~|~(\bexpr, l, v, \bullet)   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \mbox{Testing Event}
\\
% &&& \text{\mg{I think it would be better to use quadruples for events, where the}}\\
% &&& \text{\mg{first element is either a variable or a boolean expression and }}\\
% &&& \text{\mg{the last is either a query value or some default value $\bullet$}}\\
%
% \mbox{Trace} & \trace
% & ::= & \cdot | \trace \cdot \event | \trace \tracecat \trace 
% \\
%
% \mbox{Trace} & \trace
% & ::= & [] ~|~ \event:: \trace ~|~ \trace \tracecat \trace  \\
\mbox{Trace} & \trace
& ::= & [] ~|~ \trace :: \event\\
% &&& \text{\mg{I don't understand why you need both :: and ++ as constructors.}}\\
% &&& \text{\jl{Because append is to the left but we are adding element to the left in the OS}}\\
% &&& \text{\jl{I was too sticky to the convention, it is a good idea to append to the left and just use $::$}}
% %
% \mbox{Event Signature} & \sig
% & ::= & (x, l, n) | (x, l, n, \query) | (b, l, n)
% \\
% %
\end{array}
\]
% \todo{change trace notation into list, and update corresponding operator nations}
% \\
% \wqside{"$\cdot$" has two meanings? empty, delimit. Trace is list of event?}
We use following notations to represent the set of corresponding terms:
\[
\begin{array}{lll}
\mathcal{VAR} & : & \mbox{Set of Variables}  
\\ 
%
\mathcal{VAL} & : & \mbox{Set of Values} 
\\ 
%
\mathcal{QVAL} & : & \mbox{Set of Query Values} 
\\ 
%
\cdom & : & \mbox{Set of Commands} 
\\ 
%
\eventset  & : & \mbox{Set of Events}  
\\
%
\eventset^{\asn}  & : & \mbox{Set of Assignment Events}  
\\
%
\eventset^{\test}  & : & \mbox{Set of Testing Events}  
\\
%
\ldom  & : & \mbox{Set of Labels}  
\\
%%
\mathcal{VAL}  & : & \mbox{Set of Labeled Variables}  
\\
%%
\dbdom  & : & \mbox{{Set of Databases}} 
\\
%
{\mathcal{T}} & : & \mbox{Set of Traces}
\\
%
\mathcal{T}_0(c) & : & \mbox{Set of Initial Traces, where all the input variables of the program $c$ are initialized.
}
\\
%
% \qdom = {[-1,1]} & : & \mbox{{Domain of Query Results}}\\
\qdom & : & \mbox{{Domain of Query Results}}\\
% &&\text{\mg{I don't think you need to hard code [-1,1] here}}\\
\end{array}
\]
%
%
%
Environment $ \env : {\mathcal{T}}  \to \mathcal{VAR} \to \mathcal{VAL} \cup \{\bot\}$
% \mgside{The following definition is missing one case, also it is better to say that $y\neq x$.}
% \[
% \begin{array}{lll}
% \env(\trace  \tracecat [(x, l, v, \cdot)]) x \triangleq v
% &
% \env(\trace \tracecat [(y, l, v, \cdot)]) x \triangleq \env(\trace) x, y \neq x
% &
% \env(\trace \tracecat [(b, l, v, \cdot)]) x \triangleq \env(\trace) x
% \\
% \env(\trace \tracecat [(x, l, v, \qval)]) x \triangleq v
% &
% \env(\trace \tracecat [(y, l, v, \qval)]) x \triangleq \env(\trace) x, y \neq x
% &
% \env({[]} ) x \triangleq \bot
% \end{array}
% \]
\[
\begin{array}{lll}
\env(\trace  \traceadd (x, l, v, \bullet)) x \triangleq v
&
\env(\trace \traceadd (y, l, v, \bullet)) x \triangleq \env(\trace) x, y \neq x
&
\env(\trace \traceadd (b, l, v, \bullet)) x \triangleq \env(\trace) x
\\
\env(\trace \traceadd (x, l, v, \qval)) x \triangleq v
&
\env(\trace \traceadd (y, l, v, \qval)) x \triangleq \env(\trace) x, y \neq x
&
\env({[]} ) x \triangleq \bot
\end{array}
\]
%
%
% \subsection{Trace-based Operational Semantics for Language \mg{What is ``Language''?}}
\paragraph{{Trace-based Operational Semantics Extension}}
The trace based operational semantics rules are extended with the 
function procedure call, defined in Figure \ref{fig:os_extend}.
%
\begin{figure}
{
\begin{mathpar}
\boxed{
\mbox{Command $\times$ Trace}
\xrightarrow{}
\mbox{Command $\times$ Trace}
}
\and
\boxed{\config{{c, \trace}}
\xrightarrow{} 
\config{{c',  \trace'}}
}
\\
\inferrule
{
\empty
}
{
\config{\clabel{\eskip}^l,  \trace } 
\xrightarrow{} 
\config{\clabel{\eskip}^l, \trace}
}
~\textbf{skip}
%
\and
%
\inferrule
{
\event = ({x}, l, v, \bullet)
}
{
\config{[\assign{{x}}{\aexpr}]^{l},  \trace } 
\xrightarrow{} 
\config{\clabel{\eskip}^l, \trace \traceadd \event}
}
~\textbf{assn}
%
\and
%
{
\inferrule
{
 \config{\trace, \qexpr }\qarrow \qval
 \and 
\query(\qval) = v
\and 
\event = ({x}, l, v, \qval)
}
{
\config{{[\assign{x}{\query(\qexpr)}]^l, \trace}}
\xrightarrow{} 
\config{{\clabel{\eskip}^l,  \trace \traceadd \event} }
}
~\textbf{query}
}
%
\and
%
\inferrule
{
  \config{\trace, b} \barrow \etrue
 \and 
 \event = (b, l, \etrue, \bullet)
}
{
\config{{\ewhile [b]^{l} \edo c, \trace}}
\xrightarrow{} 
\config{{
c; \ewhile [b]^{l} \edo c,
\trace \traceadd \event}}
}
~\textbf{while-t}
%
%
\and
%
\inferrule
{
  \config{\trace, b} \barrow \efalse
 \and 
 \event = (b, l, \efalse, \bullet)
}
{
\config{{\ewhile [b]^{l}, \edo c, \trace}}
\xrightarrow{} 
\config{{
  \clabel{\eskip}^l,
\trace \traceadd \event}}
}
~\textbf{while-f}
%
%
\and
%
%
\inferrule
{
\config{{c_1, \trace}}
\xrightarrow{}
\config{{c_1',  \trace'}}
}
{
\config{{c_1; c_2, \trace}} 
\xrightarrow{} 
\config{{c_1'; c_2, \trace'}}
}
~\textbf{seq1}
%
\and
%
\inferrule
{
  \config{{c_2, \trace}}
  \xrightarrow{}
  \config{{c_2',  \trace'}}
}
{
\config{{\clabel{\eskip}^l; c_2, \trace}} \xrightarrow{} \config{{ c_2', \trace'}}
}
~\textbf{seq2}
%
\and
%
%
\inferrule
{
  \config{\trace, b} \barrow \etrue
 \and 
 \event = (b, l, \etrue, \bullet)
}
{
 \config{{
\eif([b]^{l}, c_1, c_2), 
\trace}}
\xrightarrow{} 
\config{{c_1, \trace \traceadd \event}}
}
~\textbf{if-t}
%
\and
%
\inferrule
{
 \config{\trace, b} \barrow \efalse
 \and 
 \event = (b, l, \efalse, \bullet)
}
{
\config{{\eif([b]^{l}, c_1, c_2), \trace}}
\xrightarrow{} 
\config{{c_2, \trace \traceadd \event}}
}
~\textbf{if-f}
% %
\and
%
\highlight{
\inferrule
{
 c' = (c)^{+n}
 \and 
 \event = (f, l, (r, x_1, \ldots, x_n) := c', \bullet)
}
{
\config{{
  [\efun]^l: f(r, x_1, \ldots, x_n) := c, \trace}}
\xrightarrow{} 
\config{{\clabel{\eskip}^l, \trace \traceadd \event}}
}
~\textbf{fun-def}
%
}
\\
\highlight{
%
\inferrule
{
  \config{ \trace, f} \earrow (r, x_1, \ldots, x_n) := c
\and 
\config{{
  \clabel{\assign{x_1}{e_1}}^{(l, 1)}; \ldots;
  \clabel{\assign{x_n}{e_n}}^{(l, n)}, \trace}} 
  \xrightarrow{}^* 
  \config{{\clabel{\eskip}^{(l, n)}, \trace_1}}
  \\ 
  \config{{\clabel{c}^{(l)}, \trace_1}}
  \xrightarrow{}^* 
  \config{{\clabel{\eskip}^{l}, \trace'}}
  \and
  \config{\trace', r } \earrow v
  \and
 \event = (x, l, v, \bullet)
}
{
\config{{
  \clabel{\assign{x}{\ecall(f, e_1, \ldots, e_n)}}^l, \trace}}
\xrightarrow{} 
\config{{\clabel{\eskip}^l, \trace' :: \event}}
}
~\textbf{fun-call}
}
%
\end{mathpar}
}
% \end{subfigure}
    \caption{Trace-based Operational Semantics for Language.}
    \label{fig:os_extend}
\end{figure}
%
\\
\highlight{
  \begin{defn}[Label Increase]
    \label{def:label_inc}  
    Label Increase $ + : {\ldom \to \mathbb{N} \to \ldom}$, increase a label $l$ by a natural number $n$:
\[
    n + n' \triangleq n'' ~ n, n' \in \mathbb{N} \land \config{[], n + n'} \aarrow n''
   \qquad (l, n) + n' \triangleq (l + n', n'') ~ n, n' \in \mathbb{N} \land \config{[], n + n'} \aarrow n''
   \]
\end{defn}
The case of $(l, n) + n'$ will never happen during evaluation.
By Operational semantics, the only place the label increase is in rule \textbf{fun-def},
$c' = (c)^{+n}$, where $c$ is the function body.
By the rule \textbf{fun-call}, and the label augment in Definition~\ref{def:comlabel_aug}, the function body $c$ will never be augmented.
%
\begin{defn}[Command Label Increase] 
  \label{def:comlabel_inc}
Command Label Increase $ {(\cdot)}{}^{+n} : {\cdom \to \cdom}$, increase the label in command by $n$.
\[
\begin{array}{ll}
  (\clabel{\assign{x}{\expr}}^l){}^{+n} & \triangleq \clabel{\assign{x}{\expr}}^{l + n}\\
(\clabel{\assign{x}{\query(\qexpr)}}^l)^{+n} & \triangleq \clabel{\assign{x}{\query(\qexpr)}}^{l + n}\\
(\clabel{\eskip}^l)^{+n} & \triangleq \clabel{\eskip}^{l + n}\\
(\ewhile \clabel{\bexpr}^{l} \edo {c'})^{+n} & \triangleq \ewhile \clabel{\bexpr}^{l+n} \edo {(c')^{+n}}\\
(\eif(\clabel{\bexpr}^{l} , {c_1}, {c_2}))^{+n}  & \triangleq \eif(\clabel{\bexpr}^{l+n} , {(c_1)^{+n}}, {(c_2)^{+n}})\\
% (\clabel{\efun}^l: x(r^l, x_1, \ldots, x_n) := c)^{+n} & \triangleq \clabel{\efun}^{l + n}: x(r^l, x_1, \ldots, x_n) := (c)^{+n} \\
(\clabel{\efun}^l: x(r^l, x_1, \ldots, x_n) := c)^{+n} & \triangleq \clabel{\efun}^{l + n}: x(r^l, x_1, \ldots, x_n) := c \\
(\clabel{\assign{x}{\ecall(x, e_1, \ldots, e_n)}}^l)^{+n} & \triangleq \clabel{\assign{x}{\ecall(x, e_1, \ldots, e_n)}}^{l + n}\\
({c_1};{c_2})^{+n} &  \triangleq {(c_1)}^{+n};{(c_2)}^{+n}
\end{array}
\]
\end{defn}
%
\begin{defn}[Command Label Augment] 
  \label{def:comlabel_aug}
  Command Label Augment $ \clabel{\cdot}^{l} : {\cdom \to \cdom}$, augment the label in command with a label $l$ 
in order to record the calling site.
\[
\begin{array}{ll}
  \clabel{\clabel{\assign{x}{\expr}}^{l'}}{}^{l} & \triangleq \clabel{\assign{x}{\expr}}^{(l, l')}\\
  \clabel{\clabel{\assign{x}{\query(\qexpr)}}^{l'}}^{l} & \triangleq \clabel{\assign{x}{\query(\qexpr)}}^{(l, l')}\\
  \clabel{\clabel{\eskip}^{l'}}^{l} & \triangleq \clabel{\eskip}^{(l, l')}\\
  \clabel{\ewhile \clabel{\bexpr}^{l'} \edo {c'}}^{l} & \triangleq \ewhile \clabel{\bexpr}^{(l, l')} \edo {(c')^{l}}\\
  \clabel{\eif(\clabel{\bexpr}^{l'} , {c_1}, {c_2})}^{l}  & \triangleq \eif(\clabel{\bexpr}^{(l, l')} , {(c_1)^{l}}, {(c_2)^{l}})\\
  \clabel{\clabel{\efun}^{l'}: x(r^l, x_1, \ldots, x_n) := c}^{l} & \triangleq \clabel{\efun}^{(l, l')}: x(r^l, x_1, \ldots, x_n) := c \\
  \clabel{\clabel{\assign{x}{\ecall(x, e_1, \ldots, e_n)}}^{l'}}^{l} & \triangleq \clabel{\assign{x}{\ecall(x, e_1, \ldots, e_n)}}^{(l, l')}\\
  \clabel{{c_1};{c_2}}^{l} &  \triangleq \clabel{c_1}^{l};\clabel{c_2}^{l}
\end{array}
\]
\end{defn}
}