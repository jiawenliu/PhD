% Another operator \mathsf{blocks} 
The standard control flow graph is generated through following steps.
\paragraph*{Vertices Construction}
The vertices of this graph is the set of $c$'s labels , 
\[ 
  \cfgV(c) = labels(c)
\]
%
% Performing a feasible data-flow analysis through the reachable definition algorithm. 
%  By generating set of all the reachable variables at location of label $l$ in the program $c$.
% For every labelled variable $x^l$ in this set, 
% the value assigned to that variable
% in the assignment command associated to that label is reachable at the entry point of  executing the command of label $l$.
\paragraph*{Edges Construction}
The edges set is constructed in following steps.
\\
\textbf{Initial State:}
%
$\cfginit(c) \in \ldom$.
\\
The \emph{initial state} for a program $c$ is the initial label of this program.
This label corresponds to the first labeled command of this program 
when executing this program.
\\
Given a program $c$, its abstract initial state is computed as follows,
%
\[
  \begin{array}{ll}
    \cfginit(\clabel{\assign{x}{\expr}}{}^l)  & = l  \\
    \cfginit(\clabel{\assign{x}{\query(\qexpr)}}{}^l)  & = l \\
    \cfginit(\clabel{\eskip}^{l})  & = l \\
    \cfginit(\eif [b]^l \ethen c_1 \eelse c_2)  & = l \\
    \cfginit(\ewhile [b]^l \edo c)  & = l \\
    \cfginit(c_1 ; c_2)  & = \cfginit(c_1) \\
 \end{array}
 \]
%

\textbf{Final State}: $\cfgfinal(c) \in \mathcal{P}(\ldom)$
The \emph{Final State} of the program $c$, 
$\cfgfinal(c) \in \mathcal{P}(\ldom)$
is a set of labels.
Every label in $\cfgfinal(c)$ corresponds to the exist point of $c$.
\\
Given a program $c$, its final state is computed as follows,
% computes the set of Final State for the command. 
 \[
  \begin{array}{ll}
    \cfgfinal(\clabel{\assign{x}{\expr}}{}^l)  & = \{l\}  \\
     \cfgfinal(\clabel{\assign{x}{\query(\qexpr)}}{}^l)  & = \{l\}  \\
     \cfgfinal(\clabel{\eskip}^{l})  & = \{l\} \\
     \cfgfinal(\eif [b]^l \ethen c_1 \eelse c_2)  & = \cfgfinal(c_1) \cup \cfgfinal(c_2) \\
     \cfgfinal(\ewhile [b]^l \edo c)  & = \{l\} \\
     \cfgfinal(c_1 ; c_2)  & =  \cfgfinal(c_2) 
 \end{array}
 \]

The control flow graph is generated by edges between labels. 
Define $\cfgflow(c): \mathcal{P}(\ldom \times \ldom)$.
%
\[
 \begin{array}{ll}
    \cfgflow(\clabel{\assign{x}{\expr}}{}^l)  & = \emptyset  \\
    \cfgflow(\clabel{\assign{x}{\query(\qexpr)}}{}^l)   & = \emptyset  \\
    \cfgflow(\clabel{\eskip}^{l})  & = \emptyset \\
    \cfgflow(\eif [b]^l \ethen c_1 \eelse c_2) & =  \cfgflow(c_1) \cup \cfgflow(c_2)\cup \{(l, \cfginit(c_1)) , (l, \cfginit(c_2)) \} \\
    \cfgflow(\ewhile [b]^l \edo c)  & =  \cfgflow(c) \cup \{(l, \cfginit(C)) \} \cup \{(l', l)| l' \in \cfgfinal(c) \} \\
    \cfgflow(c_1 ; c_2)  & = \cfgflow(c_1) \cup  \cfgflow(c_2) \cup \{ (l, \cfginit(c_2)) | l \in \cfgfinal(c_1) \} \\
 \end{array}
 \]

The edges for the control flow graph is generated as follows.
Then, I build the edge for $c$'s abstract control flow graph as follows,
\[
  \cfgE(c) = \{(l_1, l_2) | (l_1, l_2) \in \cfgflow(c)\}
  \]

%  I have a pre-processing algorithm to go through the programs and returns the list of labels associating with a loop and whose visiting times need to be analyzed.
%


\paragraph{Control Flow Graph} 
With the vertices $\cfgV(c)$ and edges $\cfgE(c)$ ready, I construct the abstract control flow graph, formally 
% Through a program $c$'s abstract execution trace, its abstract control flow graph is computed 
defined in 
Definition~\ref{def:abs_cfg}.
% Given program $c$ with its abstract control flow $\cfgflow(c)$, the Abstract Control Flow Graph:
% \\
\begin{defn}[Control Flow Graph]
\label{def:cfg_graph}
Given a program $c$, 
with its abstract control flow $\cfgflow(c)$
its abstract control flow graph $\cfgG(c) =(\cfgV(c), \cfgE(c))$ is defined as follows,
\\
% \highlight{
% :
%
% \\
$\cfgE(c) = \{(l_1, dc, l_2) | (l_1, dc, l_2) \in \cfgflow(c)\}$,
\\
$\cfgV(c) = labels(c)$
% }
% \\
% , where the weight of every label to be computed in the next step.
\end{defn}