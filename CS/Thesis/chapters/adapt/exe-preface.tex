
In this section, we formally present the definition of adaptivity for a given program.
As we discussed in Overview, we first define a dependency relation between program variables,
we then define a semantics-based dependency graph, and finally look at longest walks in this graph. 

As in Figure~\ref{fig:structure}, this is the second major part of this adaptivity analysis framework
built on the language design. 
It is more advanced than previous works
in both the accuracy and efficiency aspects.
This new adaptivity formal model defines the intuitive \emph{adaptivity} through three steps.

 \begin{enumerate}
 \item The first step in 
 Section~\ref{sec:dynamic-datadep} 
 variable \emph{may-dependency} relation based on the trace semantics in Section~\ref{sec:language-os}.
 This is the reachability perspective of this property.
 %
 \item In the second step in Section~\ref{sec:dynamic-graph}, we construct a weighted dependency graph,
the \emph{semantics-based dependency graph} of a program $c$.
This graph combines quantitative information with dependency information. 

\item The last step is the intuitive \emph{adaptivity} quantity formalization presented in Section~\ref{sec:dynamic-adapt}.
 Based on to the \emph{semantics-based dependency graph},
 I define the formal \emph{adaptivity} model in definition~\ref{def:trace_adapt} as a quantitative reachability property.
\end{enumerate}
 Through an example in Section~\ref{sec:dynamic-examples}, I show that the formalized
adaptivity matches the program's intuitive \emph{adaptivity} more precisely and efficiently than previous works.
