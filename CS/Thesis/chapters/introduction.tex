\chapter{Introduction to Quantitative Properties}
\label{introduction}


When people talk about a computer program, {they care about whether this program can bring something good and also something bad will not happen. 
The good thing happens when the program can give the users the correct answer as they expect or it can solve their problems correctly, in this case, we say that the program is \emph{functionally correct}. 
Also, the bad thing will not happen if this program executes as expected and never gets stuck, for this reason, in the programming language literature this property is often referred to as \emph{safety}.}
Actually, besides the functional correctness and safety property of a program, people also care about some other properties which describe the side effects of programs, such as the execution time, memory usage, and power consumption.
For instance, when you are installing an app on your phone, you not only care about whether the app is successfully installed, you may also want a progress bar providing an estimation time by when the installation can be done. 
These properties can usually be expressed in terms of quantities, and are called quantitative properties of programs. 

In this dissertation, I will present two studies on reasoning about quantitative properties, from different axes. 



%%%% Benifit of reasoning about 
\section{Motivation of Reasoning about Quantitative Properties}
% At the beginning, I would like to clarify the motivation of
% reasoning about quantitative properties, which has more potential benefits in today's life than before.

{Nowadays, along with the popularity of mobile devices, more and more programs will be executed on machines with limited resources. 
We have seen that games are running on smartphones and tablets, apps tracking people's health data are running on wearable devices such as smartwatches, autopilot programs are running on Unmanned Aerial Vehicles(UAV). 
For these programs, quantitative properties such as memory usage, power consumption, and execution time become very important considering the resource limit of the devices that these programs are running on. 
In this sense, reasoning about these quantitative properties has wide potential applications. }

{Another application is program optimization. 
People can safely replace a piece of code with the optimized one when they can reason about the memory usage or execution time of these two pieces of code and show the optimized one is always better. 
Reasoning about these resources can be realized by resource analysis.} 

% Reasoning about the resources consumed by a program guarantees the performance, as well as the safety on these devices. For example, we will not allow a program that may take larger memory than the embedded system it runs on, to avoid the crash due to the memory outrage. 

Another application domain is security. { Reasoning about quantitative properties can help detect side-channel attacks.  
A side-channel attack is any attack where the adversary uses some extra information from the cryptosystem. 
This extra information can be the timing information, power consumption. 
In timing channel attacks, the adversary observes the timing information of the cryptosystem handling the private information, such as the time of the system to verify one user's id and password. 
Let us assume the adversary knows the user's id (public in some other places) but does not know the password. 
The adversary can then have a malicious attempt with the user's id and a fake password. 
If the timing information of this cryptosystem is observably different from the target user's timing information, the adversary can compare the two passwords and learn the extra information on how far the two passwords are away from each other. 
Then the adversary can modify the next attempt accordingly. 
Fortunately, reasoning about the execution time of the target cryptosystem can tell us the system is resilient with respect to these attacks. 
In particular, reasoning about the difference of the execution time of the target system in two runs, one run takes arbitrary input and another one uses the password to be protected, can show that the attacker can not learn any information by observing the execution time of the two runs when the difference that is reasoned about is very small to be observed. 
This application requires relational reasoning, which is one important part of this dissertation.}

Also, quantitative properties can be used indirectly as some auxiliary component in other research. {For example, in the data analysis community, the analysts run data analysis to study some general property of some population, such as people's age in the united states. 
Instead of running their data analysis on the population( big data), they choose the sample data drawn from the population because it is often impossible to run it on the population. People use generalization errors to describe the degree that the conclusion drawn from the sample data generalizes to the population. The analysts usually ask queries to interact with the sample data. 
A study has shown that when the queries are asked adaptively, which means the choice of one query may rely on the results of other queries, the generalization error of this data analysis becomes very large. A new technique to control the generalization error is to add mechanisms. 
The key point is to choose the "right" mechanism for the data analysis. Some researchers \citep{DworkFHPRR15, BassilyNSSSU16}
shows that choice of the mechanisms for a data analysis is related to the relation between its queries. 
The relation between queries can be expressed as the length of the longest chain of queries in the algorithm such that every query in the chain may rely on its previous queries' results. The length is called adaptivity in this dissertation.}
%%%%% To reason about
\section{Methodology}
We use static analysis techniques to reason about the two main quantitative properties studied in this dissertation: 
the adaptivity of adaptive data analysis programs,
the reachability bound of while loop programs. 

\subsection{Abstract Interpretation}

\subsection{Dependency Graph}
Another quantitative property we study is the adaptivity of adaptive data analysis programs. 
{The adaptivity is defined to be the length of the longest chain of queries of the program in which one query may rely 
on its previous queries in the same chain. 
The adaptivity of a data analysis program is quite different from the relative cost of the two programs. To reason about cost, we can simply sum the costs of sub-programs to get the upper bound of the cost. However, the adaptivity of each sub-program of the target program does not help much in finding the adaptivity. To use a type and effect system to reason about adaptivity, this system should be able to express certain dependencies.
% Of course, we can sum them but then the result becomes imprecise. For this reason, we think the type and effect system is not the good direction to reason about the adaptivity of a data analysis program since it is tricky for the effect to carry information such as one query may depend on the other one. 
We expect adaptivity can also be reasoned about by type and effect systems but in this work, we choose to use a dependency graph to reason about adaptivity.}

{There are two challenges to reason about adaptivity: what will a formal definition of the adaptivity of a data analysis program look like, and how to reason about the adaptivity. 
In our work, the first challenge is solved by a query-based dependency graph generated along with the evaluation of the program. 
Our trace-based operational semantics can generate the trace which tracks the queries asked in the evaluation of the program. 
The query-based dependency graph is constructed based on the queries in the trace. Every node of the graph represents a unique query asked in the program, and the directed edge between two nodes, identifying one query (one node) may depend on the other one. 
The adaptivity is then formally defined as the length of the longest path in the query-based dependency graph.}
{The second challenge is how to estimate the adaptivity of a data analysis program we have just defined. 
In order to upper bound the length of the longest path in the query-based dependency graph, we want to find a path in a dependency graph as well such that the path contains all the queries in that longest path in the query-based dependency graph. 
We develop an algorithm to build a variable-based dependency graph, in which every node represents the unique variable that is assigned in one assignment statement of the program. 
The direct edge between two nodes reflects both the data dependency and control flow dependency between variables. Also, we add the unit weight to the node whose variable is associated with a query result. Then the upper bound on the adaptivity of the data analysis program is estimated by the weight of the path with the highest weights in the variable-based dependency graph.}

{To summarize, we use two dependency graphs for reasoning about the adaptivity of a data analysis program: 
one query-based dependency graph to define the adaptivity, and one weighted variable-based dependency graph to estimate an upper bound on the adaptivity. }

\section{Contributions}

Program analysis techniques are usually applied to study quantitative properties. In comparison to those related works, this dissertation has the following contributions.

\begin{enumerate}

\item We propose a formal definition of the adaptivity of adaptive data analysis programs and develop a graph-based program analysis algorithm that statically estimates the adaptivity.
\item reachability bound computing algorithm
% To the best of our knowledge, it is the first work that statically estimates adaptivity to help design adaptive data analysis algorithms.  
\end{enumerate}

\section{Dissertation Outline}
This dissertation includes two main parts. 
One reasons about the quantitative property (cost) of programs in the relational setting. Another one aims to use the quantitative property (adaptivity) of adaptive data programs indirectly, as an auxiliary component in data analysis research.

The rest of the dissertation is divided into $5$ parts. 
\begin{enumerate}
    \item Part \romannum{1}~ 
    
    \item Part \romannum{2}~
    
    \item Part \romannum{3}~{\ADAPTSYSTEM} shows the work on the program analysis algorithms to study the adaptivity of the adaptive data analysis program.    

Chapter~\ref{ch:adapt_intro} gives the introduction of adaptive data analysis in Section~\ref{sec:adapt-backgroung} and the challenges (Section~\ref{sec:adapt-challenges}) we face to obtain the adaptivity to control the generalization error of an adaptive data analysis program.

Chapter~\ref{ch:adapt-definition} presents the details of the loop language (Section~\ref{sec:adapt-loop-syntax}) we use to express data analysis programs, and shows the definition of adaptivity from a trace-based operational semantics in Section~\ref{sec:adapt-os}. 


Chapter~\ref{ch:adapt-algo} describes the program analysis algorithm {\ADAPTSYSTEM} that used to estimate the adaptivity of the data analysis programs (Section~\ref{sec:adapt-ve}, Section~\ref{sec:adapt-matrix}). 
The idea behind the algorithms (Section~\ref{sec:adapt-algo-ideas}) is to construct a data control dependency graph, and add weights to the graph. The adaptivity is estimated by the weight of the path with the highest weight.

Chapter~\ref{ch:adapt-example} presents some more interesting examples {\ADAPTSYSTEM} can analyse. 
It includes a variant of two round data analysis algorithm (Section~\ref{sec:adapt-example-tr-odd}), 
an adaptive multiple rounds data analysis algorithm (Section~\ref{sec:adapt-example-mr}) and an example showing the over-approximate of our approach (Section~\ref{sec:adapt-example-over}). 

Chapter~\ref{ch:adapt-relatedwork} discusses the related works from three perspectives: Static program analysis (Section~\ref{sec:adapt-rw-static}), dynamic program analysis (Section~\ref{sec:adapt-rw-dynamic}) and generalization in adaptive data analysis (Section~\ref{sec:adapt-rw-ge}).  
\item Part \romannum{4} ~ concludes the dissertation and discusses the future directions on studying the two quantitative properties: relative cost and adaptivity.
\item Part \romannum{5} ~gives the appendices. 
 The appendix~\ref{AppC} gives the proof of the lemmas of our framework in adaptive data analysis.    
\end{enumerate}



\section{Previous Published Material}
The contents of this dissertation are partly based on the work and writing in the following papers.

% The work of{\ADAPTSYSTEM} is still under preparation.


